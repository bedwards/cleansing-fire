#!/usr/bin/env python3
"""
Cleansing Fire Plugin: Social Mastodon

Posts content to any Mastodon-compatible instance via the Mastodon API v1.
Handles posting, threading, timeline reading, search, and trending tags.

Designed for the Cleansing Fire distribution pipeline â€” getting
investigated truths onto the Fediverse.

Input JSON:
  {"action": "post", "text": "...", "visibility": "public"}
  {"action": "thread", "posts": ["text1", "text2", ...], "visibility": "public"}
  {"action": "timeline", "limit": 20}
  {"action": "search", "query": "corporate lobbying", "limit": 25}
  {"action": "trending"}

Output JSON: varies by action

Required env vars:
  MASTODON_INSTANCE     - Instance URL (e.g. https://mastodon.social)
  MASTODON_ACCESS_TOKEN - OAuth access token

Manifest:
  name: social-mastodon
  category: social
  description: Posts to Mastodon instances for Fediverse content distribution
  actions:
    - name: post
      description: Post a status with configurable visibility
    - name: thread
      description: Post a threaded series of statuses
    - name: timeline
      description: Get home timeline posts
    - name: search
      description: Search posts, accounts, and hashtags
    - name: trending
      description: Get trending hashtags on the instance
  requires_env: [MASTODON_INSTANCE, MASTODON_ACCESS_TOKEN]
  uses_gatekeeper: false
  calls_plugins: []
"""

import json
import os
import sys
import time
import urllib.error
import urllib.parse
import urllib.request

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

MASTODON_INSTANCE = os.environ.get("MASTODON_INSTANCE", "").rstrip("/")
MASTODON_ACCESS_TOKEN = os.environ.get("MASTODON_ACCESS_TOKEN", "")

MASTODON_CHAR_LIMIT = 500
VALID_VISIBILITIES = ("public", "unlisted", "private", "direct")

# Rate limiting: track last post time via a temp file
RATE_LIMIT_FILE = os.path.join(
    os.environ.get("CF_PROJECT_DIR", "/tmp"),
    ".mastodon_last_post",
)
RATE_LIMIT_SECONDS = 60


# ---------------------------------------------------------------------------
# HTTP helpers
# ---------------------------------------------------------------------------

def api_url(path):
    """Build a full Mastodon API URL."""
    return f"{MASTODON_INSTANCE}/api/v1{path}"


def api_url_v2(path):
    """Build a full Mastodon API v2 URL."""
    return f"{MASTODON_INSTANCE}/api/v2{path}"


def http_request(url, data=None, method="GET", timeout=20):
    """Make an authenticated HTTP request. Returns (parsed_json, error_string)."""
    if not MASTODON_INSTANCE:
        return None, "MASTODON_INSTANCE env var not set"
    if not MASTODON_ACCESS_TOKEN:
        return None, "MASTODON_ACCESS_TOKEN env var not set"

    headers = {
        "User-Agent": "CleansingFire/0.1 SocialMastodon",
        "Authorization": f"Bearer {MASTODON_ACCESS_TOKEN}",
    }

    encoded_data = None
    if data is not None:
        # Mastodon API uses form encoding for POST
        encoded_data = urllib.parse.urlencode(data, doseq=True).encode("utf-8")
        headers["Content-Type"] = "application/x-www-form-urlencoded"

    req = urllib.request.Request(url, data=encoded_data, headers=headers,
                                method=method)
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            body = resp.read().decode("utf-8")
            if body.strip():
                return json.loads(body), None
            return {}, None
    except urllib.error.HTTPError as e:
        try:
            err_body = e.read().decode("utf-8")
            err_json = json.loads(err_body)
            msg = err_json.get("error", err_body[:200])
        except Exception:
            msg = str(e)
        return None, f"HTTP {e.code}: {msg}"
    except urllib.error.URLError as e:
        return None, f"URL error: {e.reason}"
    except Exception as e:
        return None, str(e)


# ---------------------------------------------------------------------------
# Rate limiting
# ---------------------------------------------------------------------------

def check_rate_limit():
    """Check if we are within the rate limit. Returns error dict or None."""
    try:
        if os.path.exists(RATE_LIMIT_FILE):
            with open(RATE_LIMIT_FILE, "r") as f:
                last_ts = float(f.read().strip())
            elapsed = time.time() - last_ts
            if elapsed < RATE_LIMIT_SECONDS:
                wait = int(RATE_LIMIT_SECONDS - elapsed)
                return {
                    "error": f"Rate limited. Wait {wait}s before posting again.",
                    "error_code": "RATE_LIMITED",
                    "retry_after_seconds": wait,
                }
    except (ValueError, OSError):
        pass
    return None


def record_post_time():
    """Record the current time as the last post time."""
    try:
        with open(RATE_LIMIT_FILE, "w") as f:
            f.write(str(time.time()))
    except OSError:
        pass


# ---------------------------------------------------------------------------
# Response parsing helpers
# ---------------------------------------------------------------------------

def parse_status(status):
    """Parse a Mastodon status object into a simplified dict."""
    account = status.get("account", {})

    # Strip HTML from content for plain text
    content = status.get("content", "")
    # Simple HTML tag stripping (good enough for status text)
    import re
    plain_text = re.sub(r"<[^>]+>", "", content)
    plain_text = plain_text.replace("&amp;", "&")
    plain_text = plain_text.replace("&lt;", "<")
    plain_text = plain_text.replace("&gt;", ">")
    plain_text = plain_text.replace("&quot;", '"')
    plain_text = plain_text.replace("&#39;", "'")
    plain_text = plain_text.strip()

    return {
        "id": status.get("id", ""),
        "uri": status.get("uri", ""),
        "url": status.get("url", ""),
        "author_acct": account.get("acct", ""),
        "author_name": account.get("display_name", ""),
        "text": plain_text,
        "visibility": status.get("visibility", ""),
        "created_at": status.get("created_at", ""),
        "favourites_count": status.get("favourites_count", 0),
        "reblogs_count": status.get("reblogs_count", 0),
        "replies_count": status.get("replies_count", 0),
        "in_reply_to_id": status.get("in_reply_to_id"),
    }


# ---------------------------------------------------------------------------
# Action: post
# ---------------------------------------------------------------------------

def action_post(input_data):
    """Post a status to Mastodon."""
    text = input_data.get("text", "").strip()
    if not text:
        return {"error": "Missing required field: 'text'", "error_code": "MISSING_FIELD"}

    if len(text) > MASTODON_CHAR_LIMIT:
        return {
            "error": f"Text exceeds {MASTODON_CHAR_LIMIT} character limit "
                     f"({len(text)} chars)",
            "error_code": "TEXT_TOO_LONG",
        }

    visibility = input_data.get("visibility", "public")
    if visibility not in VALID_VISIBILITIES:
        return {
            "error": f"Invalid visibility: '{visibility}'. "
                     f"Must be one of: {', '.join(VALID_VISIBILITIES)}",
            "error_code": "INVALID_VISIBILITY",
        }

    # Rate limit check
    rl = check_rate_limit()
    if rl:
        return rl

    # Build the post data
    post_data = {
        "status": text,
        "visibility": visibility,
    }

    # Optional reply
    reply_to_id = input_data.get("reply_to_id", "")
    if reply_to_id:
        post_data["in_reply_to_id"] = reply_to_id

    # Optional content warning / spoiler text
    spoiler = input_data.get("spoiler_text", "")
    if spoiler:
        post_data["spoiler_text"] = spoiler

    # Optional language
    language = input_data.get("language", "")
    if language:
        post_data["language"] = language

    url = api_url("/statuses")
    result, err = http_request(url, data=post_data, method="POST")
    if err:
        return {"error": f"Post failed: {err}", "error_code": "POST_FAILED"}

    record_post_time()

    return {
        "id": result.get("id", ""),
        "uri": result.get("uri", ""),
        "url": result.get("url", ""),
        "text": text,
        "visibility": visibility,
        "char_count": len(text),
        "created_at": result.get("created_at", ""),
        "type": "mastodon_post",
    }


# ---------------------------------------------------------------------------
# Action: thread
# ---------------------------------------------------------------------------

def action_thread(input_data):
    """Post a threaded series of statuses."""
    posts = input_data.get("posts", [])
    if not posts or not isinstance(posts, list):
        return {
            "error": "Missing required field: 'posts' (list of strings)",
            "error_code": "MISSING_FIELD",
        }

    if len(posts) < 2:
        return {
            "error": "Thread requires at least 2 posts",
            "error_code": "INVALID_INPUT",
        }

    visibility = input_data.get("visibility", "public")
    if visibility not in VALID_VISIBILITIES:
        return {
            "error": f"Invalid visibility: '{visibility}'. "
                     f"Must be one of: {', '.join(VALID_VISIBILITIES)}",
            "error_code": "INVALID_VISIBILITY",
        }

    # Validate all post lengths before starting
    for i, text in enumerate(posts):
        if not isinstance(text, str) or not text.strip():
            return {
                "error": f"Post {i+1} is empty or not a string",
                "error_code": "INVALID_INPUT",
            }
        if len(text) > MASTODON_CHAR_LIMIT:
            return {
                "error": f"Post {i+1} exceeds {MASTODON_CHAR_LIMIT} chars "
                         f"({len(text)} chars)",
                "error_code": "TEXT_TOO_LONG",
            }

    # Rate limit check
    rl = check_rate_limit()
    if rl:
        return rl

    results = []
    parent_id = None

    for i, text in enumerate(posts):
        text = text.strip()
        post_data = {
            "status": text,
            "visibility": visibility,
        }

        if parent_id is not None:
            post_data["in_reply_to_id"] = parent_id

        url = api_url("/statuses")
        result, err = http_request(url, data=post_data, method="POST")
        if err:
            return {
                "error": f"Thread failed at post {i+1}: {err}",
                "error_code": "THREAD_FAILED",
                "posted": results,
                "failed_at": i + 1,
            }

        parent_id = result.get("id", "")

        results.append({
            "index": i + 1,
            "id": parent_id,
            "uri": result.get("uri", ""),
            "url": result.get("url", ""),
            "text": text,
            "char_count": len(text),
        })

        # Small delay between posts to be respectful to the instance
        if i < len(posts) - 1:
            time.sleep(0.5)

    record_post_time()

    return {
        "thread_root_id": results[0]["id"] if results else "",
        "thread_root_url": results[0].get("url", "") if results else "",
        "posts": results,
        "count": len(results),
        "visibility": visibility,
        "type": "mastodon_thread",
    }


# ---------------------------------------------------------------------------
# Action: timeline
# ---------------------------------------------------------------------------

def action_timeline(input_data):
    """Get home timeline posts."""
    limit = min(input_data.get("limit", 20), 40)
    max_id = input_data.get("max_id", "")
    since_id = input_data.get("since_id", "")

    params = {"limit": limit}
    if max_id:
        params["max_id"] = max_id
    if since_id:
        params["since_id"] = since_id

    url = api_url("/timelines/home") + "?" + urllib.parse.urlencode(params)
    result, err = http_request(url, method="GET")
    if err:
        return {"error": f"Timeline fetch failed: {err}", "error_code": "TIMELINE_FAILED"}

    if not isinstance(result, list):
        return {
            "error": "Unexpected timeline response format",
            "error_code": "PARSE_ERROR",
        }

    posts = [parse_status(s) for s in result]

    return {
        "posts": posts,
        "count": len(posts),
        "type": "mastodon_timeline",
    }


# ---------------------------------------------------------------------------
# Action: search
# ---------------------------------------------------------------------------

def action_search(input_data):
    """Search posts, accounts, and hashtags."""
    query = input_data.get("query", "").strip()
    if not query:
        return {"error": "Missing required field: 'query'", "error_code": "MISSING_FIELD"}

    limit = min(input_data.get("limit", 25), 40)
    search_type = input_data.get("type", "")  # statuses, accounts, hashtags

    params = {"q": query, "limit": limit}
    if search_type:
        params["type"] = search_type

    url = api_url_v2("/search") + "?" + urllib.parse.urlencode(params)
    result, err = http_request(url, method="GET")
    if err:
        return {"error": f"Search failed: {err}", "error_code": "SEARCH_FAILED"}

    # Parse statuses
    statuses = [parse_status(s) for s in result.get("statuses", [])]

    # Parse accounts
    accounts = []
    for acct in result.get("accounts", []):
        accounts.append({
            "id": acct.get("id", ""),
            "acct": acct.get("acct", ""),
            "display_name": acct.get("display_name", ""),
            "note": acct.get("note", ""),
            "followers_count": acct.get("followers_count", 0),
            "following_count": acct.get("following_count", 0),
            "statuses_count": acct.get("statuses_count", 0),
            "url": acct.get("url", ""),
        })

    # Parse hashtags
    hashtags = []
    for tag in result.get("hashtags", []):
        history = tag.get("history", [])
        recent_uses = sum(int(h.get("uses", 0)) for h in history[:7])
        hashtags.append({
            "name": tag.get("name", ""),
            "url": tag.get("url", ""),
            "recent_uses_7d": recent_uses,
        })

    return {
        "query": query,
        "statuses": statuses,
        "accounts": accounts,
        "hashtags": hashtags,
        "counts": {
            "statuses": len(statuses),
            "accounts": len(accounts),
            "hashtags": len(hashtags),
        },
        "type": "mastodon_search",
    }


# ---------------------------------------------------------------------------
# Action: trending
# ---------------------------------------------------------------------------

def action_trending(input_data):
    """Get trending hashtags on the instance."""
    limit = min(input_data.get("limit", 20), 40)

    # Trending tags
    url = api_url("/trends/tags") + "?" + urllib.parse.urlencode({"limit": limit})
    tags_result, tags_err = http_request(url, method="GET")

    # Trending statuses (Mastodon 3.5+)
    url_statuses = api_url("/trends/statuses") + "?" + urllib.parse.urlencode(
        {"limit": min(limit, 20)}
    )
    statuses_result, statuses_err = http_request(url_statuses, method="GET")

    # Parse trending tags
    trending_tags = []
    if not tags_err and isinstance(tags_result, list):
        for tag in tags_result:
            history = tag.get("history", [])
            day_uses = []
            for h in history[:7]:
                day_uses.append({
                    "day": h.get("day", ""),
                    "uses": int(h.get("uses", 0)),
                    "accounts": int(h.get("accounts", 0)),
                })
            total_uses = sum(d["uses"] for d in day_uses)
            total_accounts = sum(d["accounts"] for d in day_uses)
            trending_tags.append({
                "name": tag.get("name", ""),
                "url": tag.get("url", ""),
                "total_uses_7d": total_uses,
                "total_accounts_7d": total_accounts,
                "history": day_uses,
            })

    # Parse trending statuses
    trending_statuses = []
    if not statuses_err and isinstance(statuses_result, list):
        trending_statuses = [parse_status(s) for s in statuses_result]

    output = {
        "tags": trending_tags,
        "tags_count": len(trending_tags),
        "type": "mastodon_trending",
    }

    if trending_statuses:
        output["statuses"] = trending_statuses
        output["statuses_count"] = len(trending_statuses)

    if tags_err:
        output["tags_error"] = tags_err
    if statuses_err:
        output["statuses_error"] = statuses_err

    return output


# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------

def main():
    try:
        raw = sys.stdin.read() if not sys.stdin.isatty() else ""
        if not raw.strip():
            json.dump(
                {
                    "error": "No input provided. Send JSON on stdin with an 'action' field.",
                    "error_code": "INVALID_INPUT",
                    "details": {
                        "valid_actions": ["post", "thread", "timeline",
                                          "search", "trending"],
                        "examples": {
                            "post": {"action": "post", "text": "Hello Fediverse!",
                                     "visibility": "public"},
                            "thread": {"action": "thread",
                                       "posts": ["First post", "Second post"]},
                            "timeline": {"action": "timeline", "limit": 20},
                            "search": {"action": "search",
                                       "query": "corporate lobbying"},
                            "trending": {"action": "trending"},
                        },
                        "env_required": ["MASTODON_INSTANCE",
                                         "MASTODON_ACCESS_TOKEN"],
                    },
                },
                sys.stdout,
                indent=2,
            )
            sys.exit(2)

        input_data = json.loads(raw)
    except json.JSONDecodeError as e:
        json.dump(
            {"error": f"Invalid JSON input: {e}", "error_code": "INVALID_INPUT"},
            sys.stdout,
            indent=2,
        )
        sys.exit(2)

    if not isinstance(input_data, dict):
        json.dump(
            {"error": "Input must be a JSON object", "error_code": "INVALID_INPUT"},
            sys.stdout,
            indent=2,
        )
        sys.exit(2)

    action = input_data.get("action", "")
    if not action:
        json.dump(
            {
                "error": "Missing required field: 'action'",
                "error_code": "MISSING_FIELD",
                "details": {
                    "valid_actions": ["post", "thread", "timeline",
                                      "search", "trending"],
                },
            },
            sys.stdout,
            indent=2,
        )
        sys.exit(2)

    # Dispatch
    if action == "post":
        result = action_post(input_data)
    elif action == "thread":
        result = action_thread(input_data)
    elif action == "timeline":
        result = action_timeline(input_data)
    elif action == "search":
        result = action_search(input_data)
    elif action == "trending":
        result = action_trending(input_data)
    else:
        result = {
            "error": f"Unknown action: '{action}'",
            "error_code": "UNKNOWN_ACTION",
            "details": {
                "valid_actions": ["post", "thread", "timeline",
                                  "search", "trending"],
            },
        }

    json.dump(result, sys.stdout, indent=2)

    # Exit with appropriate code
    if "error" in result:
        error_code = result.get("error_code", "")
        if error_code in ("INVALID_INPUT", "MISSING_FIELD", "UNKNOWN_ACTION"):
            sys.exit(2)
        else:
            sys.exit(1)


if __name__ == "__main__":
    main()
